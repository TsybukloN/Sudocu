/* autogenerated by Processing revision 1293 on 2024-03-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import java.util.ArrayList;
import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sudocu extends PApplet {



PImage icon;
PFont usual, seted, dropdownList;
PVector tooltipPosition;
ControlP5 difficultyTool, sizeTool;

int size = 10,
  blockSizeX = 5,
  blockSizeY = size/blockSizeX;

int cellSize,
  selectedRow = -1,
  selectedCol = -1;

boolean isGameStarted = true,
  isSolved = false;

int difficulty = 1;

long startTime, elapsedTimeInSeconds;

ArrayList<Character> digits = new ArrayList<>();

class cell {
  char value;
  char solved;
  boolean free;
};

cell[][] sudokuBoard;

public void setup() {
  /* size commented out by preprocessor */;
  
  strokeWeight(2);
  textAlign(CENTER, CENTER);
  
  usual = createFont("Arial", 27);
  seted = createFont("Comic Sans MS", 26);
  dropdownList = createFont("Arial", 14);

  icon = loadImage("icon.png");
  surface.setIcon(icon);

  tooltipPosition = new PVector(width - 120, 50);

  difficultyTool = new ControlP5(this);
  difficultyTool.addDropdownList("difficulty")
    .setPosition(0, 0)
    .setSize(110, 200)
    .setCaptionLabel("Big-O (Easy)")
    .setFont(dropdownList)
    .addItem("Easy", 0)
    .addItem("Medium", 1)
    .addItem("Hard", 2)
    .setItemHeight(25)
    .setBarHeight(25);

  sizeTool = new ControlP5(this);
  sizeTool.addDropdownList("size")
    .setPosition(120, 0)
    .setSize(106, 200)
    .setCaptionLabel("Size (10x10)")
    .setFont(dropdownList)
    .addItem("6x6", 0)
    .addItem("9x9", 1)
    .addItem("10x10", 2)
    .addItem("14x14", 3)
    .setItemHeight(25)
    .setBarHeight(25);

  startInitializeBoard();
  fillInitialValues(1);
}

public void draw() {
  background(255);
  drawGrid();
  drawNumbers();

  if (isGameStarted) {
    displayTooltip();
  }

  if (isCorrectSolved()) {
    isSolved = true;
  }
}

public void mousePressed() {
  selectedRow = mouseY / cellSize;
  selectedCol = mouseX / cellSize;
}

public void keyPressed() {
  if (selectedRow != -1 && selectedCol != -1 && sudokuBoard[selectedRow][selectedCol].free) {
    char keyChar = Character.toUpperCase((char)key);
    if (digits.contains(keyChar)) {
      sudokuBoard[selectedRow][selectedCol].value = keyChar;
      
    } else if (keyChar == BACKSPACE) {
      sudokuBoard[selectedRow][selectedCol].value = ' ';
    }
  }

  if (keyCode == UP && selectedRow > 0) {
    selectedRow--;
  } else if (keyCode == DOWN && selectedRow < size-1) {
    selectedRow++;
  } else if (keyCode == LEFT && selectedCol > 0) {
    selectedCol--;
  } else if (keyCode == RIGHT && selectedCol < size-1) {
    selectedCol++;
  }
}
public void drawGrid() {
  for (int i = 0; i <= size; i++) {
    if (i % blockSizeY == 0) {
      stroke(0);
    } else {
      stroke(200);
    }
    line(0, i * cellSize, width, i * cellSize);
  }

  for (int i = 0; i <= size; i++) {
    if (i % blockSizeX == 0) {
      stroke(0);
    } else {
      stroke(200);
    }
    line(i * cellSize, 0, i * cellSize, height);
  }
}

public void drawNumbers() {
  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      if (!sudokuBoard[i][j].free) {
        textFont(usual);
      } else {
        textFont(seted);
      }
      fill(0);
      text(sudokuBoard[i][j].value, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
    }
  }

  if (selectedRow != -1 && selectedCol != -1) {
    fill(150, 200, 255, 150);
    rect(selectedCol * cellSize, selectedRow * cellSize, cellSize, cellSize);
  }
}

public void displayTooltip() {
  if (!isSolved && mouseX > width - 25 && 10 <= mouseY && mouseY <= 90) {
    long hours = elapsedTimeInSeconds / 3600;
    long minutes = (elapsedTimeInSeconds % 3600) / 60;
    long seconds = elapsedTimeInSeconds % 60;

    String formattedTime = String.format("%02d:%02d:%02d", hours, minutes, seconds);

    fill(200, 220, 255, 200);
    rect(tooltipPosition.x - 200/2, tooltipPosition.y - 75/2, 200, 75);
    fill(0);
    textFont(usual);
    text("Time: " + formattedTime, tooltipPosition.x, tooltipPosition.y);
  } else if (isSolved) {
    long hours = elapsedTimeInSeconds / 3600;
    long minutes = (elapsedTimeInSeconds % 3600) / 60;
    long seconds = elapsedTimeInSeconds % 60;

    String formattedTime = String.format("%02d:%02d:%02d", hours, minutes, seconds);

    fill(200, 220, 255, 200);
    rect(tooltipPosition.x - 200/2, tooltipPosition.y - 75/2, 200, 75);
    fill(0, 127, 0);
    textFont(usual);
    text("Time: " + formattedTime, tooltipPosition.x, tooltipPosition.y);
  } else {
    fill(50, 122, 254);
    rect(tooltipPosition.x + 95, tooltipPosition.y - 75/2, 25, 75);

    fill(0);

    float angle = -HALF_PI;
    translate(tooltipPosition.x + 108, tooltipPosition.y);
    rotate(angle); 
    textFont(usual);
    text("time", 0, 0);

    rotate(-angle);
    translate(-(tooltipPosition.x + 108), -tooltipPosition.y);
  }

  if (!isSolved) {
    elapsedTimeInSeconds = (millis() - startTime) / 1000;
  }
}

public void controlEvent(ControlEvent theEvent) {
  if (theEvent.isFrom("difficulty")) {
    difficulty = (int)theEvent.getController().getValue() + 1;
  }

  if (theEvent.isFrom("size")) {
    int selectedDifficulty = (int)theEvent.getController().getValue();
    switch(selectedDifficulty) {
    case 0:
      size = 6;
      blockSizeX = 3;
      break;
    case 1:
      size = 9;
      blockSizeX = 3;
      break;
    case 2:
      size = 10;
      blockSizeX = 5;
      break;
    case 3:
      size = 14;
      blockSizeX = 7;
      break;
    }

    blockSizeY = size/blockSizeX;
    startInitializeBoard();
  }

  cleanBoard();
  fillInitialValues(difficulty);
  startTime = millis();
  isGameStarted = true;
  isSolved = false;
}



public void startInitializeBoard() {
  sudokuBoard = new cell[size][size];

  setDigits();
  cellSize = width / size;

  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      sudokuBoard[i][j] = new cell();
      sudokuBoard[i][j].value = ' ';
    }
  }
}

public void cleanBoard() {
  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      sudokuBoard[i][j].value = ' ';
      sudokuBoard[i][j].solved = ' ';
    }
  }
}

public void setDigits() {
  int j = 0;
  digits.clear();
  digits.ensureCapacity(size);

  for (char x = '1'; x <= '9' && j++ < size; x++) {
    digits.add(x);
  }

  for (char x = 'A'; x <= 'X' && j++ < size; x++) {
    digits.add(x);
  }
}

public boolean isValidMove(int row, int col, char num) {
  for (int i = 0; i < size; i++) {
    if ((sudokuBoard[row][i].value == num && i != col) || (sudokuBoard[i][col].value == num && i != row)) {
      return false;
    }
  }

  int subgridStartRow = row - row % blockSizeY;
  int subgridStartCol = col - col % blockSizeX;
  for (int i = 0; i < blockSizeY; i++) {
    for (int j = 0; j < blockSizeX; j++) {
      if (sudokuBoard[subgridStartRow + i][subgridStartCol + j].value == num && subgridStartRow + i != row && subgridStartCol + j != col) {
        return false;
      }
    }
  }

  return true;
}

public boolean isCorrectSolved() {
  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      if (sudokuBoard[i][j].value != sudokuBoard[i][j].solved) {
        return false;
      }
    }
  }

  return true;
}

public void fillInitialValues(int level) {
  boolean fromStartFlag = false;

  for (int i = 0; i < size; i++) {
    fromStartFlag = false;
    for (int j = 0; j < size; j++) {
      ArrayList<Character> set = new ArrayList<Character>(digits);

      while (set.size() > 0) {
        int randomIndex = (int) random(0, set.size());
        char candidate = set.get(randomIndex);

        if (isValidMove(i, j, candidate)) {
          sudokuBoard[i][j].value = candidate;
          break;
        }

        set.remove(randomIndex);
      }

      if (sudokuBoard[i][j].value == ' ') {
        if (fromStartFlag) {
          fromStartFlag = false;
          i = 0;
          cleanBoard();
        } else {
          fromStartFlag = true;
          for (int u = 0; u < j; u++) {
            sudokuBoard[i][u].value = ' ';
          }
        }

        j = -1;
      }
    }
  }

  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
      sudokuBoard[i][j].solved = sudokuBoard[i][j].value;
      if (random(0, level+1) >= 1) {
        sudokuBoard[i][j].value = ' ';
        sudokuBoard[i][j].free = true;
      } else {
        sudokuBoard[i][j].free = false;
      }
    }
  }
}


  public void settings() { size(1260, 1260); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sudocu" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
